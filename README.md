# Algorithms
* [Binary Search](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/algorithms/binary_search.js)

# Data Structures
* [Linked List](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/data_structures/lists/linked_list.js)
* [Stack](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/data_structures/lists/stack.js)
* [Queue](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/data_structures/lists/queue.js)
* [Binary Search Tree](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/data_structures/trees/binary_search_tree.js)
* [Graphs](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/data_structures/graphs) - [Full Course](https://www.youtube.com/watch?v=tWVWeAqZ0WU)

# Problems
* [Minimum Domino Rotations For Equal Row](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/min_domino_rotations.js): [LeetCode](https://leetcode.com/problems/minimum-domino-rotations-for-equal-row/)
>
* [Valid Parentheses](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/valid_parentheses.js): [LeetCode](https://leetcode.com/problems/valid-parentheses/)
>Sabe-se que todo parênteses, colchete ou chaves aberto precisa ser fechado na ordem em que ele foi aberto. Se um parênteses for aberto e depois um colchete, o parênteses deve ser fechado primeiro e depois o colchete. Para isso, usar o conceito de pilhas (LIFO). Sempre que um sinal for aberto é colocado na fila. Sempre que for fechado, verifica-se o último elemento da fila e, caso seja seu complementar estará válido. Caso contrário, inválido.
* [Candy Types](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/candy_types.js): [LeetCode](https://leetcode.com/problems/distribute-candies/)
>Primeiro, o número de doces permitidos será sempre metade do tamanho da lista de tipos de doces que ela possui. Usando um map onde a chave é o tipo e o valor é a quantidade daquele tipo, iterar a lista e preencher o map com essas informações. Sabendo agora a quantidade de doces de cada tipo, se o tamanho da quantidade permitida for maior que o tamanho do map de tipos, sabe-se que ela poderá comer de todos os tipos então é só retornar o tamanho do map. Caso contrário, iterar sobre o map sempre reduzindo 1 de cada tipo de doce e incrementando 1 ao contador enquanto estive dentro do limite permitido de doces que ela pode comer. Retornar o contador.
* [String Compression](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/string_compress.js): [LeetCode](https://leetcode.com/problems/string-compression/)
>A ideia desse exercício é economizar memória. Então os caracteres devem ser reorganizados e **não** criar uma nova string como resposta. Usando dois ponteiros (leitura e escrita) percorrer a string. O ponteiro de leitura incrementa o contador enquanto a letra encontrada for igual à última letra lida. Caso a letra troque, o ponteiro de escrita escreve a letra, anda 1 e escreve o valor do contador e volta o valor do contador para 1.
* [Two Sum](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/two_sum.js): [LeetCode](https://leetcode.com/problems/two-sum)
>A ideia é retornar a posição de dois números de um array que somados dão o valor que se quer encontrar (target). Usando um map (chave:valor) onde a chave é o complementar (_target_ menos número atual da lista) e o valor é o index. Percorrer a lista: o map será povoado com o complementar ao número e seu respectivo index. Caso o valor complementar seja encontrado, o array de indexes recebe o índice atual e o índice do complementar guardado no map.
* [Best Time to Buy and Sell Stock](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/buy_sell_stock.js): [LeetCode](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
>A ideia é comprar o mais barato possível e vender o mais caro possível para otimizar os lucros. Usando dois ponteiros: venda e compra. A compra começa na posição zero e a venda na posição 1 (pois não posso vender no passado). O ponteiro de compra fica parado em um número até que (e se) for encontrado um número menor. O ponteiro de compra percorre toda a lista tentando encontrar o maior número possível para a venda. E, caso encontre um número menor que o atual de compra, o ponteiro de compra muda de posição.
* [Evaluate Reverse Polish Notation](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/polish_notation.js): [LeetCode](https://leetcode.com/problems/evaluate-reverse-polish-notation/) >[Solução utilizada](https://leetcode.com/problems/evaluate-reverse-polish-notation/solutions/486566/javascript-stack-solution/)<
> Usar o conceito de pilhas. Sempre que um sinal de operação matemática for encontrado, dar um pop() nos dois últimos elementos da pilha e realizar a operação entre estes. Caso haja mais de dois números na pilha, o próximo sinal de operação encontrado realizará a operação com o resultado encontrado anteriormente e o número que estava lá antes da operação. Isso garante a ordem das operações. Pois um sinal sempre aparece imediatamente após os núemros para os quais essa operação deve ser realizada.
* [Biggest Sub String](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/biggest_sub_string.py): [LeetCode](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
> A ideia inicial poderia ser iterar por toda a lista a partir de cada caracter. Mas isso elevaria a complexidade de tempo do algoritmo de forma exponencial. A solução apresentada aqui utiliza dois ponteiros. O "right" percorre toda a lista adicionando os caracteres a um "set" e incrementado o tamanho max até que encontre algum repetido (que já foi adiiconado ao set). Nesse caso, o "left" começa a iterar sobre a lista, removendo todos os caracteres já encontrados no set. Até chegar ao caracter em que "right" está parado, que seria o repetido. Chegando neste, adiciona-se o caracter "right" (já que todos foram removidos) e "right" continua seu processo.
* [Square Root] (https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/square_root.py): [LeetCode](https://leetcode.com/problems/sqrtx/description/)
> Encontrar o inteiro mais próximo à raiz quadrada de um número sem o uso de bibliotecas. Para isso, utilizo dois ponteiros: "left" em zero e "right" em x (o número a ser encontrada a raiz). Para melhorar o tempo faço uma busca binária. Pensando que left e right podem ser abstraídos como sendo uma lista de números de zero a x, consigo ir testando sempre pela metade. Se o número do meio vezes ele mesmo for maior que o próprio x, esse número não pode ser sua raiz quadrada. Então vamos para a primeira metade dessa possível lista de números. Se for menor, vamos para a segunda metade. Quando restarem apenas 2 números, retornamos o menor. No caso, o "left". E com isso temos a menor raiz inteira de um número.
* [Search Suggestion System]:(https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/search_suggestion.py) [LeetCode](https://leetcode.com/problems/search-suggestions-system/description/)
> Primeiro dar um "sort" na lista de produtos. Para cada letra na palavra a ser buscada, iterar sob a lista de produtos buscando as palavras que contenham as mesmas letras, na mesma posição e adicionando á lista de sugestões com limite de 3 palavras.
* [Closest K Number](https://github.com/IaraSelva/study-cases-of-living-coding/blob/main/solved_problems/closest_k_number.py): [LeetCode](https://leetcode.com/problems/k-closest-points-to-origin/description/)
> À partir do cálculo da distância entre os pontos (com a fórmula dada) é necessário devolver os pontos com a menor distância. Para isso eu preciso armazenar os dois valores: distância e pontos por isso uso um dicionário. Após armazenar todas as diatências de cada ponto, crio uma lista só com as distâncias e ordeno com "sort". Dessas distâncias, que são as chaves do dicionário eu acesso os pontos e retorno os k primeiros.
  
